#include <iostream>
#include <vector>
#include <math.h>
#include <omp.h>
#include <Rcpp.h>
#include <Rmath.h>

using namespace Rcpp;

//struct for open mp lock
//Custom Container for omp_lock_t
//Written by: Joel Yliluoma
//http://bisqwit.iki.fi/story/howto/openmp/
#ifdef _OPENMP
struct MutexType{
  MutexType(){omp_init_lock(&lock);}
  ~MutexType(){omp_destroy_lock(&lock);}
  void Lock(){omp_set_lock(&lock);}
  void Unlock(){omp_unset_lock(&lock);}

  MutexType(const MutexType&){omp_init_lock(&lock);}
  MutexType& operator = (const MutexType&){return *this;}
public:
  omp_lock_t lock;
};
#else
/* A dummy mutex that doesn't actually exclude anything,
 * but as there is no parallelism either, no worries. */
struct MutexType{
  void Lock(){}
  void Unlock(){}
};
#endif
//end of custom container

//struct for storing cluster elements, contains sequence, cardinality and minimum distance
struct element{
  std::vector<int> seq;
  std::vector<int> card;
  float dist = 0;
};

float* getTables(int alphabetSize); //Function returns table
int promoteCard(int cardLow, int dataLow, int cardHigh, int dataHigh, bool suppressWarnings); //Function that promotes cardinality of a iSAX word
float eucDis(std::vector<float> rawData1, std::vector<float> rawData2); //Function that calculates the Euclidean distance between two time series
float minDis(std:: vector<int> SAXData1, std::vector<int> card1, std::vector<int> SAXData2, std::vector<int> card2, int rawDataSize,bool suppressWarnings); //Function that calculates the minimum distance between two iSAX words
std::vector<element> kMedian(std::vector<int> seq, std::vector<int> card, int step, int windowSize,int clusterNum, std::vector<element> centroidIn, bool prevCentroid); //Function that calculates the kMedian

//globally used variables
std::map<int,float*> tablesMap; //Map used for storying values generated by getTable function
static bool cardError = false; //Supress Warning and Error Messages

// [[Rcpp::export]]
List runKMedian(NumericMatrix seq, NumericMatrix card, int step, int windowSize, int clusterNum, NumericMatrix centroidSeq, NumericMatrix centroidCard, bool prevCentroid = false){
  std::vector<element> centroid;

  //if the user wants to use inputted centroids
  if(prevCentroid){
    //test if the centroid dimensions are valid
    if((centroidSeq.nrow() != centroidCard.nrow())||(centroidSeq.ncol() != centroidCard.ncol())||(centroidSeq.ncol() != windowSize)){
      Rf_error("Error: Your input Centroid sequence or cardinality don't have the correct dimensions");
      return List::create();
    }
    //put inputted centroids in centroid vector
    for(int i = 0; i < centroidSeq.nrow(); i++){
      NumericVector tempCentSeq = centroidSeq.row(i);
      NumericVector tempCentCard = centroidCard.row(i);
      element temp;
      temp.seq = as<std::vector<int>>(tempCentSeq);
      temp.card = as<std::vector<int>>(tempCentCard);
      centroid.push_back(temp);
    }
  }
  //iterate through all sequences given and feed into kMedian function
  for(int i = 0; i < seq.nrow(); i++){
    NumericVector tempSeq = seq.row(i);
    NumericVector tempCard = card.row(i);
    centroid = kMedian(as<std::vector<int>>(tempSeq),as<std::vector<int>>(tempCard),step,windowSize,clusterNum, centroid, prevCentroid);
    prevCentroid = true;
  }

  List resultCentroids(clusterNum);
  for(int i = 0; i < clusterNum; i++)
    resultCentroids.at(i) = List::create(Named("Sequence") = wrap(centroid.at(i).seq), Named("Cardinality") = wrap(centroid.at(i).card));

  return resultCentroids;
}

// [[Rcpp::export]]
List reconstruct(std::vector<int> seq, std::vector<int> card, int step, List centroidList){
  int centroidNum = centroidList.length();
  std::vector<element> centroids;
  centroids.reserve(centroidNum);
  centroids.resize(centroidNum);

  std::vector<int> recSeq;
  recSeq.reserve(seq.size());
  recSeq.resize(seq.size());

  //extract centroid data from list and save into centroids vector of elements
  for(int i = 0; i < centroidNum; i++){
    centroids.at(i).seq = as<std::vector<int>>(as<List>(centroidList.at(i)).at(0));
    centroids.at(i).card = as<std::vector<int>>(as<List>(centroidList.at(i)).at(1));
  }
  int windowSize = centroids.at(0).seq.size();
  int tile = 4096*step; //tbd

#pragma omp parallel for
  for(int ii = 0; ii <= (seq.size()-windowSize); ii+=tile){
    for(int i = ii; i < (ii+tile) && i <= (seq.size()-windowSize); i+=step){
      element temp;
      temp.seq.assign(seq.begin()+i,seq.begin()+i+windowSize);
      temp.card.assign(card.begin()+i,card.begin()+i+windowSize);

      std::vector<float> dist;
      for(int c= 0; c < centroidNum; c++)
        dist.push_back(minDis(centroids.at(c).seq,centroids.at(c).card,temp.seq,temp.card,seq.size(),true));

      std::vector<float>::iterator it= std::min_element(dist.begin(), dist.end());
      int centroidIndex = std::distance(dist.begin(),it);

      int m = step;
      if(i == seq.size()-windowSize)
        m = windowSize;

      for(int e = 0; e < m; e++)
        recSeq.at(i+e) = centroids.at(centroidIndex).seq.at(e);
    }
  }
  //finding difference vector
  std::vector<int> diff;
  diff.reserve(seq.size());
  diff.resize(seq.size());
  tile = 4096; //tbd
#pragma omp parallel for
  for(int ii = 0; ii < seq.size(); ii+=tile)
    for(int i = ii; i < (ii+tile) && i < seq.size(); i++)
      diff.at(i) = seq.at(i) - recSeq.at(i);
  return List::create(Named("Reconstructed_Sequence") = wrap(recSeq), Named("Difference_Vector") = wrap(diff));
}

// function that returns table based on normal gaussian distribution
float *getTables(int alphabetSize) {

  if(tablesMap.find(alphabetSize) == tablesMap.end()){
    float *tempTable = new float[alphabetSize - 1];
    double interval = 1 / (double)alphabetSize;
    int tile = 10; //tbd

#pragma omp parallel for
    for (int ii = 1; ii < alphabetSize; ii += tile)
      for (int i = ii; i < ii + tile && i < alphabetSize; i++)
        tempTable[i - 1] = ((float)R::qnorm(i * interval, 0.0, 1.0, 1, 0));
    tablesMap.insert (std::pair<int,float*> (alphabetSize,tempTable));
    return tempTable;
  }
  else
    return tablesMap.find(alphabetSize) -> second;
}

//function that promotes the data of lower cardinality to the data of higher cardinality
int promoteCard(int cardLow, int dataLow, int cardHigh, int dataHigh, bool suppressWarnings){
  int shiftNum = ceil(log2(cardHigh)) - ceil(log2(cardLow));

  if(suppressWarnings)
    cardError = true;
  if((((int)log2(cardHigh) != ceil(log2(cardHigh)))||((int)log2(cardLow) != ceil(log2(cardLow))))&&(!cardError)){
    cardError = true;
    Rf_warning("One or more of your Cardinalities are not of base 2. This may cause some error in the result.");
  }

  dataLow = dataLow << shiftNum;
  if(dataLow < dataHigh){
    int diff = dataHigh - dataLow;
    for(int i = shiftNum - 1; i >= 0; i --){
      int bitAdd = i*2;
      if(bitAdd <= diff){
        diff -= bitAdd;
        dataLow += bitAdd;
      }
      else
        continue;
      if(diff == 0)
        break;
    }
  }
  return dataLow;
}

//Euclidean distance calculated using raw values
// [[Rcpp::export]]
float eucDis(std::vector<float> rawData1, std::vector<float> rawData2){
  float distance = 0;
  if(rawData1.size()==rawData2.size()){
    int dataSize = rawData1.size();

#pragma omp parallel for reduction(+:distance)
    for(int i = 0; i < dataSize; i++){
      distance += pow((rawData1.at(i)-rawData2.at(i)), 2);
    }
    distance = sqrt(distance);
  }
  else
    std::cerr<<"Error the length of the SAX words are not the same"<<std::endl;

  return distance;
}

//Minimum distance calculated using SAX Words
// [[Rcpp::export]]
float minDis(std:: vector<int> SAXData1, std::vector<int> card1, std::vector<int> SAXData2, std::vector<int> card2, int rawDataSize,bool suppressWarnings = false){
  float distance = 0;
  if((SAXData1.size()==SAXData2.size())&&(card1.size() == card2.size()) && (SAXData1.size() == card1.size())){
    float* bkPts;
    int dataSize = SAXData1.size();
    int tile = 4096; //tbd
#pragma omp parallel for
    for(int ii = 0; ii < dataSize; ii+=tile){
      for(int i = ii; i < (ii+tile) && i < dataSize; i++){
        if(card1.at(i) > card2.at(i)){
          SAXData2.at(i) = promoteCard(card2.at(i),SAXData2.at(i), card1.at(i), SAXData1.at(i),suppressWarnings);
          card2.at(i) = card1.at(i);
        }
        else if(card1.at(i) < card2.at(i)){
          SAXData1.at(i) = promoteCard(card1.at(i), SAXData1.at(i), card2.at(i), SAXData2.at(i),suppressWarnings);
          card1.at(i) = card2.at(i);
        }
        bkPts = getTables(card1.at(i));
        if(std::abs(SAXData1.at(i) - SAXData2.at(i)) > 1){
          distance += pow(bkPts[(int)fmax(SAXData1.at(i), SAXData2.at(i))-1] - bkPts[(int)fmin(SAXData1.at(i), SAXData2.at(i))],2);
        }
      }
    }
    distance = std::sqrt(distance);
    distance *= std::sqrt(rawDataSize/SAXData1.size());
  }
  return distance;
}

//calculates the kMedians of a sequence of values
std::vector<element> kMedian(std::vector<int> seq, std::vector<int> card, int step, int windowSize,int clusterNum, std::vector<element> centroidIn, bool prevCentroid = false){
  int index = 0;
  if(seq.size() != card.size()){
    Rf_error("Error: The sequence does not match the cardinality size");
    return centroidIn;
  }
  //Assignment of centroids
  if(!prevCentroid){
    centroidIn.clear();
    if(clusterNum > seq.size()-windowSize){
      Rf_error("There are too many clusters and too little groups in the sequence");
      return centroidIn;
    }
    centroidIn.reserve(clusterNum);
    centroidIn.resize(clusterNum);
    for(int i = 0; i < clusterNum; i++){
      element tempCent;
      tempCent.seq.assign(seq.begin()+index,seq.begin()+index+windowSize);
      tempCent.card.assign(card.begin()+index,card.begin()+index+windowSize);
      centroidIn.at(i) = (tempCent);
      index += step;
    }
    if(clusterNum == seq.size()-windowSize)
      return centroidIn;
  }
  else if((centroidIn.at(0).seq.size() != windowSize)||(centroidIn.at(0).card.size() != windowSize)){
    Rf_error("Error: The median sequence or the median cardinality is not the same size as the window size");
    return centroidIn;
  }
  //End of assignment of centroids

  //locks for open mp when inserting into clusters to prevent race conditions/bad sorting
  MutexType *lock = new MutexType[clusterNum];

  //array of vectors to hold each cluster
  std::vector<element> *cluster = new std::vector<element>[clusterNum];
  std::vector<float> *distCluster = new std::vector<float>[clusterNum];
  //iterate through each possible group of size 'windowSize' and interval 'step' in the sequence
  int tile = 4096*step; //tbd
#pragma omp parallel for
  for(int ii = index; ii <= (seq.size()-windowSize); ii+=tile){
    for(int i = ii; i < (ii+tile) && i <= (seq.size()-windowSize);i+=step){
      //temp element to hold the current element
      element temp;
      temp.seq.assign(seq.begin()+i,seq.begin()+i+windowSize);
      temp.card.assign(card.begin()+i,card.begin()+i+windowSize);

      //vector of distance calculations to find the min between each centroid of clusters
      std::vector<float> dist;

      //iterate through centroids and save distance between the current vector and the centroid
      for(int c = 0; c < clusterNum; c++)
        dist.push_back(minDis(centroidIn.at(c).seq,centroidIn.at(c).card,temp.seq,temp.card,seq.size(),true));

      //get the iterator for the minimum of the vector
      std::vector<float>::iterator it= std::min_element(dist.begin(), dist.end());
      //set the value of the minimum distance of the vector
      temp.dist = *it;
      //determine which cluster the element belongs in
      int clusterIndex = std::distance(dist.begin(),it);

      if(distCluster[clusterIndex].empty()){
        distCluster[clusterIndex].push_back(temp.dist);
        cluster[clusterIndex].push_back(temp);
      }
      else{
        int insertIndex = std::distance(distCluster[clusterIndex].begin(), std::upper_bound(distCluster[clusterIndex].begin(),distCluster[clusterIndex].end()-1, temp.dist));

        lock[clusterIndex].Lock();
        distCluster[clusterIndex].insert(distCluster[clusterIndex].begin()+insertIndex, temp.dist);
        cluster[clusterIndex].insert(cluster[clusterIndex].begin()+insertIndex, temp);
        lock[clusterIndex].Unlock();
      }
    }
  }

  for(int i = 0; i < clusterNum; i++){
    if(cluster[i].size() != 0)
      centroidIn.at(i) = cluster[i].at((int)((cluster[i].size()-1)/2));
    else
      return kMedian(seq,card,step,windowSize,clusterNum,centroidIn,false);
  }
  return centroidIn;
}
