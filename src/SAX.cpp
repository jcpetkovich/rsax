#include <iostream>
#include <vector>
#include <map>
#include <math.h>
#include <omp.h>
#include <Rcpp.h>
#include <Rmath.h>

using namespace Rcpp;

float* getTable(int alphabetSize); //Function returns table
void normData(std::vector<float> *data, std::vector<float> *norm); //Function that normalizes the inputted data
void toPAA(std::vector<float> *data, std::vector<float> *PAA, int segSize); // Function that converts normalized data into PAA
void toSAX(std::vector<float> *data, std::vector<int> *SAXWord, std::vector<int> *card, int numBkPts); //Funciton that converts PAA to SAX Word

//globally used variables
std::map<int,float*> tableMap; //Map used for storying values generated by getTable function

//' Convert a time series into a SAX Word.
//' @title Convert to SAX (runSAX)
//' @param orgData A vector of time series data to be converted to a SAX Word.
//' @param segmentSize The size of each segment taken when converting to SAX Word.
//' @param alphabetSize The size of the alphabet for classification of PAAs to SAX Words.
//' @param iSAX False: returns only the SAX Word. True: returns SAX Word and Cardinality.
//' @return A Vector that contains the SAX Word and if iSAX = true a Vector that contains its corresponding Cardinality.
// [[Rcpp::export]]
RObject runSAX(std::vector<float> orgData, int segmentSize, int alphabetSize, bool iSAX = false) {
  //normalize data
  std::vector<float> nrmData;
  normData(&orgData, &nrmData);

  //calculate PAA for data
  std::vector<float> PAA;

  toPAA(&nrmData, &PAA, segmentSize);

  //assign SAX values based on PAA value
  std::vector<int> card;
  std::vector<int> SAXWordFinal;

  toSAX(&PAA, &SAXWordFinal, &card, alphabetSize);
  //return values
  if (iSAX)
    return List::create(_["SAXWord"] = SAXWordFinal, _["Cardinality"] = card);
  else
    return wrap(SAXWordFinal);
}

// function that returns table based on normal gaussian distribution
float *getTable(int alphabetSize) {

  if(tableMap.find(alphabetSize) == tableMap.end()){
    float *tempTable = new float[alphabetSize - 1];
    double interval = 1 / (double)alphabetSize;
    int tile = 10; //tbd

#pragma omp parallel for
    for (int ii = 1; ii < alphabetSize; ii += tile)
      for (int i = ii; i < ii + tile && i < alphabetSize; i++)
        tempTable[i - 1] = ((float)R::qnorm(i * interval, 0.0, 1.0, 1, 0));
    tableMap.insert (std::pair<int,float*> (alphabetSize,tempTable));
    return tempTable;
  }
  else
    return tableMap.find(alphabetSize) -> second;
}

// normalize data to have mean of 0 and standard deviation of 1 for SAX
// conversion
void normData(std::vector<float> *data, std::vector<float> *norm){
  float mean = 0;  // mean of the data
  float StDev = 0; // standard deviation of the data
  int tile = 4096 * std::pow(2, 2);

  float sumx = 0.0f, sumx2 = 0.0f;
#pragma vector aligned
#pragma omp parallel for default(shared) reduction(+ : sumx,                   \
  sumx2) schedule(guided)
    for (decltype(data->size()) i = 0; i < data->size(); i++) {
      sumx += data->at(i);
      sumx2 += data->at(i) * data->at(i);
    }
    mean = sumx / data->size();
  StDev = sqrtf(sumx2 / data->size() - mean * mean);

  // normalizing data
  int dataSize = data->size();
  norm->reserve(dataSize);
  norm->resize(dataSize);

  float invStDev = 1 / StDev;
#pragma vector aligned
#pragma omp parallel for
  for (int ii = 0; ii < dataSize; ii += tile) {
    for (int i = ii; i < ii + tile && i < dataSize; i++) {
      norm->at(i) = ((data->at(i)) - mean) * invStDev;
    }
  }
}

// dimensionality reduction of data into segment sizes of the user's choice
void toPAA(std::vector<float> *data, std::vector<float> *PAA, int segSize){
  // iterating for each segment of data in Time Series data

  int dataSize = data->size();
  int perThread = 4096; // tbd
  int tile = segSize * perThread;

  PAA->reserve(ceil((float)dataSize / (float)segSize));
  PAA->resize(ceil((float)dataSize / (float)segSize));

#pragma omp parallel for
  for (int ii = 0; ii < dataSize; ii += tile) {
    for (int i = ii; i < ii + tile && i < dataSize; i += segSize) {
      float sum = 0;
      // averaging for each segment
      int m;
      for (m = i; m < (i + segSize) && m < dataSize; m++) {
        sum += data->at(m);
      }
      // PAA -> push_back(sum/segSize);

      PAA->at(i / segSize) = sum / (m-i);
    }
  }
}

// Converting PAA to SAX

/*
 Note: Interval Numbering
 Interval number will be the value of the index greater than the value

 Example:
 Data: 0.2
 intervals: interval [2] = 0.1, interval [3] = 0.4
 Interval Number: 3
 */
void toSAX(std::vector<float> *data, std::vector<int> *SAXWord, std::vector<int> *card, int numBkPts){
  float *bkPts =
    getTable(numBkPts); // get table values for number of breakpoints chosen

  int dataSize = data->size();

  SAXWord->reserve(dataSize);
  SAXWord->resize(dataSize);
  card->reserve(dataSize);
  card->resize(dataSize);
  int tile = 4096;
  // iterating through PAA data
#pragma omp parallel for
  for (int ii = 0; ii < dataSize; ii += tile) {
    for (int i = ii; i < ii + tile && i < dataSize; i++) {
      int counter = 0;
      for (int m = 0; m < numBkPts - 1; m++) {
        if (data->at(i) > bkPts[m])
          counter++;
      }
      // SAXWord -> push_back(counter);
      // card -> push_back(numBkPts);
      SAXWord->at(i) = counter;
      card->at(i) = numBkPts;
    }
  }
}

// This function is used to test the outputs of the normData function
// [[Rcpp::export]]
RObject runNormData(std::vector<float> data) {
  std::vector<float> norm;
  normData(&data, &norm);
  return wrap(norm);
}

// This function is used to test the outputs of the to PAA function
// [[Rcpp::export]]
RObject runToPAA(std::vector<float> data, int segSize) {
  std::vector<float> PAA;
  toPAA(&data, &PAA, segSize);
  return wrap(PAA);
}

// This function is used to test the outputs of the to SAX function
// [[Rcpp::export]]
RObject runToSAX(std::vector<float> data, int brkPtNum) {
  std::vector<int> SAXWord;
  std::vector<int> card;
  toSAX(&data, &SAXWord, &card, brkPtNum);
  return wrap(SAXWord);
}
